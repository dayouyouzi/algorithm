
给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 最短时间 。

 

示例 1：

输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 





int leastInterval(vector<char>& tasks, int n) {
        int len=tasks.size();//求出任务数大小
        vector<int> vec(26);
        for(char c:tasks) ++vec[c-'A'];//计算字符出现次数
        sort(vec.begin(),vec.end(),[](int& x,int&y){return x>y;});//次数降序，ves[0],为最大出现次数，为桶的个数
        int cnt=1;//vec[1]开始查找，出于vec[0]想同次数的个数，放在最后一个桶中
        while(cnt<vec.size()&&vec[cnt]==vec[0]) cnt++;
        return max(len,cnt+(n+1)*(vec[0]-1) );//若任务数大于求得的时间，则返回任务数
				//若小，则返回求得的时间
    }				//总结起来：总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数
				//cnt为最后一个桶的任务数
				//vec[0] - 1