给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。


这个范围内，别管是怎么跳的，反正一定可以跳过来。

那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！

每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。

贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。




bool canJump(vector<int>& nums) 
{
	int k = 0;//设初始范围为0
	for (int i = 0; i < nums.size(); i++)
	{
		if (i > k) return false;//若遍历的i，最终大于最大范围，说明达不到最后，返回false
		k = max(k, i + nums[i]);//范围大小存储在k中，范围刷新，取之前存储在k的范围，
				//和此时i范围(i+nums[i])的最大值
	}
	return true;//遍历结束，说明能到达，返回true
}

